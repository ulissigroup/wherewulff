"""
Copyright (c) 2022 Carnegie Mellon University.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
"""

import uuid
import json
import itertools

import re
import numpy as np
from scipy.spatial.distance import pdist, squareform
from pydash.objects import has, get

# ASE/Pymatgen
from ase.constraints import FixAtoms
from pymatgen.io.ase import AseAtomsAdaptor as AAA
from pymatgen.core.periodic_table import Element
from pymatgen.core.structure import Structure
from pymatgen.core.surface import Slab

# OCP
import torch
from ocpmodels.common.relaxation.ase_utils import OCPCalculator
from ocpmodels.common.utils import setup_imports
from ocpmodels.preprocessing import AtomsToGraphs
from ocpmodels.datasets import data_list_collater
from ocpmodels.common.utils import setup_imports
from ocpmodels.trainers import ForcesTrainer

# Fireworks/Atomate
from fireworks import FireTaskBase, FWAction, explicit_serialize
from atomate.utils.utils import env_chk, get_logger
from atomate.vasp.config import VASP_CMD, DB_FILE
from atomate.vasp.database import VaspCalcDb

logger = get_logger(__name__)

@explicit_serialize
class OERIntermediatesMLFireTask(FireTaskBase):
    """
    Given a dict of structure of OER single site,
    as the one from WhereWulff/reactivity/oer.py:
    {"reference", "OH_0", "OH_1",...,"OOH_up_0",..., "OOH_down_0",...,}.
    Return the most stable configuration for OH and OOH.

    Args:
        intermediates_dict   (dict): Intermediates dict from /WhereWulff/reactivity/oer.py
        reduced_formula      (str) : Slab reduced formula.
        miller_index         (str) : Miller index of the given surface e.g 110
        metal_site           (str) : OER site composition (selecting the metal)
        model_checkpoint     (env) : Environment variable to the best OCP model checkpoint.
        model_config         (env) : Environment variable to the OCP model configuration file.
        db_file              (env) : Environment variable to connect to the DB.

    Returns:
        The most stable configuration of each OER intermediate,
        previously generated by WhereWulff/reactivity/oer.py method.
    """

    required_params = ["intermediates_dict",
     "reduced_formula",
     "miller_index",
     "metal_site",
     "model_checkpoint", 
     "model_config", 
     "db_file"
    ]
    optional_params = []

    def run_task(self, fw_spec):

        # Global variables
        intermediates_dict = self["intermediates_dict"]
        reduced_formula = self["reduced_formula"]
        miller_index = self["miller_index"]
        metal_site = self["metal_site"]
        model_checkpoint = env_chk(self["model_checkpoint"], fw_spec)
        model_config = env_chk(self["model_config"], fw_spec)
        db_file = env_chk(self.get("db_file"), fw_spec)
        summary_dict = {"reduced_formula": reduced_formula,
                        "miller_index": miller_index,
                        "metal_site": metal_site,
                        "model_checkpoint": model_checkpoint,
                        "model_config": model_config}

        # Coneect to DB
        mmdb = VaspCalcDb.from_db_file(db_file, admin=True)

        # Init the OCP calculator
        calc = OCPCalculator(model_config, 
                    checkpoint=model_checkpoint)

        # Init Atoms2Graph
        a2g = AtomsToGraphs(max_neigh=50,
                            radius=6,
                            r_energy=False,
                            r_forces=False,
                            r_distances=False,
                            r_edges=False)

        # Loop over OER intermediates
        OH_atoms, OOH_up_atoms, OOH_down_atoms = [], [], []
        for oer_inter_label, oer_inter in intermediates_dict.items():
            # select OH intermediates
            if re.match("^OH_.*", oer_inter_label):
                # From PMG object to ASE-object with tags
                oer_intermediate, _ = self._get_ase_object(struct=oer_inter)
                # Append to list
                OH_atoms.append(oer_intermediate)
            
            if re.match("^OOH_up_.*", oer_inter_label):
                # From PMG object to ASE-object with tags
                oer_intermediate, _ = self._get_ase_object(struct=oer_inter)
                # Append to list
                OOH_up_atoms.append(oer_intermediate)

            if re.match("^OOH_down_.*", oer_inter_label):
                # From PMG object to ASE-object with tags
                oer_intermediate, _ = self._get_ase_object(struct=oer_inter)
                # Append to list
                OOH_down_atoms.append(oer_intermediate)

        # From ASE-objects to graphs
        OH_graphs = a2g.convert_all(OH_atoms)
        OOH_up_graphs = a2g.convert_all(OOH_up_atoms)
        OOH_down_graphs = a2g.convert_all(OOH_down_atoms)

        # Add tags inside graph representation
        OH_graphs = self._add_tags_to_graphs(graph_batch=OH_graphs, atoms_list=OH_atoms)
        OOH_up_graphs = self._add_tags_to_graphs(graph_batch=OOH_up_graphs, atoms_list=OOH_up_atoms)
        OOH_down_graphs = self._add_tags_to_graphs(graph_batch=OOH_down_graphs, atoms_list=OOH_down_atoms)

        # Batch of graphs ready to predict
        OH_graphs_batch = data_list_collater(OH_graphs, otf_graph=True)
        OOH_up_graphs_batch = data_list_collater(OOH_up_graphs, otf_graph=True)
        OOH_down_graphs_batch = data_list_collater(OOH_down_graphs, otf_graph=True)

        # Predicting
        OH_pred = calc.trainer.predict(
            OH_graphs_batch, per_image=False, disable_tqdm=True
        )
        OOH_up_pred = calc.trainer.predict(
            OOH_up_graphs_batch, per_image=False, disable_tqdm=True
        )
        OOH_down_pred = calc.trainer.predict(
            OOH_down_graphs_batch, per_image=False, disable_tqdm=True
        )

        # Sort the predictions to find the most stable configurations
        OH_stable_index = OH_pred["energy"].sort().indices[0].item()
        OOH_up_stable_index = OOH_up_pred["energy"].sort().indices[0].item()
        OOH_down_stable_index = OOH_down_pred["energy"].sort().indices[0].item()

        # From energy index to ASE-object
        OH_stable_config = OH_atoms[OH_stable_index].copy()
        OOH_up_stable_config = OOH_up_atoms[OOH_up_stable_index].copy()
        OOH_down_stable_config = OOH_down_atoms[OOH_down_stable_index].copy()

        # ASE-object back to PMG structure
        OH_stable_config = self._get_pmg_struct(OH_stable_config)
        OOH_up_stable_config = self._get_pmg_struct(OOH_up_stable_config)
        OOH_down_stable_config = self._get_pmg_struct(OOH_down_stable_config)

        # Intermediates dict
        reference_dict = {"reference": intermediates_dict["reference"].as_dict()}
        oh_dict = {f"OH_{OH_stable_index}": OH_stable_config.as_dict()}
        ooh_up_dict = {f"OOH_up_{OOH_up_stable_index}": OOH_up_stable_config.as_dict()}
        ooh_down_dict = {f"OOH_down_{OOH_down_stable_index}": OOH_down_stable_config.as_dict()}

        # Return it as oer_intermediates dict
        oer_intermediates_ml = {
            **reference_dict,
            **oh_dict,
            **ooh_up_dict,
            **ooh_down_dict,
        }

        # Store into summary_dict
        summary_dict["intermediates_ml"] = oer_intermediates_ml

        # Collection
        mmdb.collection = mmdb.db[f"{reduced_formula}_{miller_index}_{metal_site} OER_intermediates_ml"]
        mmdb.collection.insert_one(summary_dict)

        # Export POSCARS to visualize
        for key, value in oer_intermediates_ml.items():
            value_struct = Structure.from_dict(value)
            value_struct.to(filename=f"POSCAR_{key}")

        # Logger
        logger.info("OER Intermediates screening with ML, Done!")

        return

    def _get_ase_object(self, struct):
        """Convert to ASE-object and add constraints"""
        # Convert PMG structure to ASE
        atoms = AAA.get_atoms(struct)
        # Apply the tags for relaying to gemnet model
        constraint_indices = atoms.todict()["constraints"][0].get_indices()
        surface_properties = atoms.todict()["surface_properties"]
        tags = []
        for (is_adsorbate, atom) in zip(surface_properties, atoms):
            if atom.index in constraint_indices:
                tags.append(0) # bulk-like
            elif atom.index not in constraint_indices and not is_adsorbate:
                tags.append(1) # surface
            else:
                tags.append(2) # adsorbate
        atoms.set_tags(np.array(tags).astype(int))
        return atoms, tags

    def _add_tags_to_graphs(self, graph_batch, atoms_list):
        """Add tags to a batch of graphs"""
        for graph, atoms in zip(graph_batch, atoms_list):
            graph.tags = torch.LongTensor(
                atoms.get_tags().astype(int)
            )
        return graph_batch

    def _get_pmg_struct(self, atoms_object):
        """From ASE-objec to PMG struct"""
        return AAA.get_structure(atoms_object)
